
> 相較於SQL語法的專研, Design是更重要的

正規化的結果是經過一連串計算後的客觀且一致的結果, 但會降低完備性

一樣是top-Down的設計

#### normal forms
- 1NF
- 2NF
- 3NF
- BCNF(Boyce-Codd Normal Form)

##### DB Design Guideline ： 
- relation都可以清楚的表示單一概念
	- FK的選擇也是極為重要
	- attribute跟FK的分界需要清楚
	- 在使用者看到attribute後可以很直覺的關聯到table本身
- 盡可能減少DB anomly(insert, delete...)的產生
	- 通常是因為attr或table沒有清楚定義(如把employee跟project混在一起)
	- 當emp沒有被assign project前不可以有新的project
	- 如果想要刪除project, 會把僅參與該project的emp直接從這個DBMS中移除了
	- 通常會產生更多的redundent(同一個project name會重複很多次等)
- 盡可能減少null欄位的發生
- 避免發生genteration of Spurious Tuple(最重要的)(lossless join)
	- 通常會在JOIN時產生, 產生的tuple是不必要的, 被稱為"lossy join", 產生的tuple被稱為spurious tuple
	- 會讓table的constrain消失
	- emp_locs與emp_proj兩個混合的table做join(找到proj的emp的location)

> functional dependecy可以看作是一種constrain

違反constrain的情況例如emp_proj, emp_locs的table

當把emp_proj join emp_locs時會產生很多不必要的tuple(爆炸的多), 還會產生錯誤的資料(supriuos tuple), 因為兩個只能用Plocation來作連結, 而join時所使用的Plocation本身是很寬鬆的, constrain會無法被限制在同一個人(所有在同一個plocation的都會被重複count到)


#### functional dependecies(FDs)

- Are used to specify formal measures of the "goodness" of relational designs
- And keys are userd to define **normal forms** for relations
- Are **constraints** that are derived from the meaning and interrelationships of the data attributes

##### Defining Functional Dependencies
- For any two tuples t1 and t2 in any relation instance r(R): if t1[X] == t2[X], then t1[Y] == t2[Y]
- X -> Y in R sepecifies a constraint on all relation instances r(R)
- X -> Y can be displayed graphically on a relation schema as in Figures.
- FDs are derived from the real-world constraints on the attributes

但 X -> Y 不等於 Y-> X
e.g.
SSN -> Ename // 但反過來如 Ename -> SSN 不一定成立, 會有同名同姓的情況
Pnumber -> {Pname, Plocation}
{SSN, Pnumber} -> Hours

> 不可以有多對一

> table中會有很多FDs, 但通常只需要找出核心的relation就好了, 通常會想要找到key的FD



#### Normalization 

如數值會有不同的表示方式, 將欄位做標準化會把標準統一

denormalize則是把標準化後的數值轉回正常表示方式

通常會做到3NF 或 BCNF


a set of Super key is not must be a optimal set


A **prime attribute** must be a member of some candidate key
A Nonprime attribute is not a prime attribute

##### Disallows
- composite attribute
- multivalued attributes
- nested relation; 

###### solutions
multivalued attribute -> 
1. turn into a small table 
2. add new attribute for new value -> sparely the table, ambiguos of new attribute from mother attribute


2NF -> trun a large table to small table
- purpose :  all dependecy should be full functional dependecy, not allow for X1 -> Y1, and X1->Y2

3NF -> 
![[tempFileForShare_20250812-180554.jpg]]

1NF -> 2NF : we found conty_name & Lot# can be a candidate key, chose them, and decouple the attribute which only be decide by only one of prime attribute (non full functional dependency)
- Conty_name -> tax_rate

2NF -> 3NF : 
**Transtive functional dependency** : a FD X->Z that can be derived from two FDs X->Y and Y->Z

> 2NF is aim to eliminate redutent
> 3NF is aim to change indirect to direct relation

BCNF用集合論來看需要滿足
（（R1 AND R2) -> (R1 - R2)) is in F+, or
（（R1 AND R2) -> (R2 - R1)) is in F+
任意條件即可進行Decomposition(D)
e.g.
- D1: {<u>student, instructor</u>} and {<u>student, course</u>}
- D2: {course , <u>instructor</u>} and {<u>course, student</u>}
- D3: {<u>instructor</u>, course} and {<u>instructor, student</u>}

#### 4NF, 5NF

4NF -> MVD(multivalue dependecy)
5NF -> JD(join dependen)
