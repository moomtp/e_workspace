

Meanings of NULL
- Unknown value (不知道)
- Unavailable or withheld value (不可以, 不想要)
- Not applicable attribute (不允許, 如女性僱員的兵役欄位)







![[tempFileForShare_20250719-152508.jpg]]

```
SELECT Fname, Lname
FROM EMPLOYEE
WHERE Super_ssn IS NULL;
```

###### Nest queries
通常會放在WHERE裡面

```
SELECT DISTINCT Pnumber
FROM PROJECT
WHERE PNnumber IN
		(SELECT Pnumber
		FROM PROJECT,DEPARTMENT, EMPLOYEE
		WHERE Dnum == Dnumber AND
			Mgr_ssn == Ssn AND Lname == 'Smith')
	OR
	Pnumber IN
		(
		SELECT Pno
		FROM EMPLOYEE, WORKS_ON
		WHERE Essn == Ssn AND Lname == 'Smith')
		)
```

另外一種用法 ：
```
SELECT DISTINCT Essn
FROM WORKS_ON
WHERE (Pno, Hours) IN (Select Pno, Hours
						FROM WORKS_ON
						WHERE Essn == '23042309');
```

###### Condition + Nested Queries
```
SELECT Lname, Fname
FROM EMPLOYEE
WHERE Salary > ALL (
					SELECT Salary
					FROM EMPLOYEE
					WHERE Dno == 5);
```

多層nest要小心, 別名重疊的情形
```
SELECT E.Fname, E.Lname
FROM EMPLOYEE AS E
WHERE E.Ssn IN(
				SELECT Essn
				FROM DEPENDENT AS D
				WHERE E.Fname == D.Dependent_name
					AND E.Sex == D.Sex);
```

上面也可以寫成用join的方式來處理
```
SELECT E.Fname, E.Lname
FROM EMPLOYEE AS E, DEPARTMENT AS D
WHERE E.Ssn == D.Essn AND E.Sex == D.Sex
	AND E.Fname == D.Dependent_name
```

###### EXISTS and UNIQUE
EXISTS用來確認值是否存在
```
SELECT Fname, Lname
FROM Employee
WHERE EXISTS (
				SELECT *
				FROM DEPENDENT
				WHERE Ssn == Essn)
		AND EXISTS(
				SELECT *
				FROM Department
				WHERE Ssn == Mgr_Ssn)

```

double negation ： 在取某些條件下的全部會常用
```
SELECT Fname, Lname
FROM Employee
WHERE NOT EXISTS ((
				SELECT Pnumber
				FROM PROJECT
				WHERE Dno == 5)
		EXCEPT(
				SELECT Pno
				FROM WORK_ON
				WHERE Ssn == ESsn)
```
Department 5參與的所有project的所有人
不這樣做會要寫多層迴圈

會變這樣 很炸
```
SELECT Fname, Lname
FROM Employee
WHERE NOT EXISTS (
				SELECT *
				FROM WORKS_ON B
				WHERE (
						B.Pno IN
							(SELECT Pnumber
							FROM PROJECT
							WHERE Dnum == 5
							
								AND
								NOT EXISTS
								(
									SELECT *
									FROM WORKS_ON C
									WHERE C.Essn == Ssn
									AND C.Pno == B.Pno )));
```


###### explict set

```
SELECT DISTINCT Essn
FROM WORKS_ON
WHERE Pno IN(1,2,3);
```

```
SELECT E.Lname AS Employee_name, S.Lname AS Supervisor_name
FROM EMPLOYEE AS E, EMPLOYEE AS S
WHERE E.Super_ssn == S.Ssn;
```

##### JOIN ON
原本是from兩個table後用where條件做join (equal join)
SQL提供了JOIN ON的方式把原本where裡面的條件放到on的後面

NATURAL JOIN : 如果兩個table有相同的attribute, 則可以直接做JOIN
```
SELECT Fname, Lname, Address
FROM (MEPLOYEE NATURAL JOIN
	(DEPARTMENT AS DEPT(Dname, Dno, Mss, Msdate)))
WHERE Dname == 'Research';
```

以上都是INNER JOIN
INNER JOIN ： 只找符合條件的

OUTER JOIN ： 不腐和條件的也會表現出來
e.g. : LEFT OUTER JOIN, RIGHER OUTER JOIN, CROSS PUDUCT

假設要找所有員工的query, 且不管有沒有直屬上司都做保留
```
SELECT E.Lname AS Employee_Name
	 S.Lname AS Supervisor_Name
FROM Employee AS E LEFT OUTER JOIN EMPLOYEE AS S
					ON E.Super_ssn == S.Ssn)

-- 相同結果但用equal join方法
SELECT E.Lname AS Employee_Name
FROM EMPLOYEE E ,EMPLOYEE S
WHERE E.Super_ssn += S.Ssn
```
+= 相當於left join

#### Aggregate Function

COUNT, SUM, MAX, MIN, and AVG 這些都是Aggregate Function, 通常會放在SELECT中
通常會搭配 HAVING使用

e.g.
```
SELECT SUM(Salary), MAX(Salary), MIN(Salary), AVG(Salary)
FROM EMPLOYEE;
```
AVG不會計入null的個數作為分母

COUNT
```
SELECT COUNT(*);
FROM EMPLOYEE;

```

count 會在過濾完(where完成)之後才會count
```
SELECT COUNT(*);
FROM EMPLOYEE, DEPARTMENT;
WHERE Dno == Dnumber AND Dname == 'Research';
```

##### Grouping
GOURP BY : 為aggergate function給與不同組別, aggergate function會在組別內進行運算
如果沒有用GROUP BY, 會算出整個table的結果

在GROUP BY中出現的, 在SELECT 一定找得到對應

```
SELECT Dno, COUNT(*), AVG(Salary)
FROM EMPLOYEE
GROUP BY Dno;
```
GOURP BY後面可以用逗號接多個值
```
SELECT Pnumber, Pname, COUNT(*), AVG(Salary)
FROM PROJECT, WORKS_ON
WHERE Pnumber == Pno
GROUP Pnumber, Pname;
```

##### HAVING
針對aggregate後的值再進行一次過濾
```
SELECT Pnumber, Pname, COUNT(*), AVG(Salary)
FROM PROJECT, WORKS_ON
WHERE Pnumber == Pno
GROUP BY Pnumber, Pname;
HAVING COUNT(*) > 2;
```
僅取筆數 > 2的

###### WHERE + HAVING的使用方法

需求 ： 找出dapartment人數 > 5 人且其中薪水 > 40000得人
```
-- 不正確的
SELECT Dno, COUNT(*)
FROM DEPARTMENT, EMPLOYEE
WHERE Salary > 40000
GROUP BY Dno
HAVING COUNT(*) > 5;
```
因為上面的 只會把> 40000的 > 5 人的department找出來
HAVING會在where後才做

正確的
```
SELECT Dnumber, COUNT(*)
FROM DEPARTMENT, EMPLOYEE
WHERE Dnumber == Dno AND Salary > 40000 AND
	( SELECT Dno
		FROM EMPLOYEE
		GROUP BY Dno
		HAVING COUNT(*) > 5 )
```


##### WITH
用來創建temp view(virtual table)
```
WITH DIGDEPTS(Dno) AS
(
	SELECT Dno
	FROM EMPLOYEE
	GROUP BY Dno
	HABING COUNT(*) > 5 )

SELECT Dno, COUNT(*)
FROM EMPLOYEE
WHERE Salary > 40000 AND Dno IN BIGDEPTS
GROUP BY Dno;
```

##### CASE 
```
UPDATE EMPLOYEE
SET Salary = 
CASE WHEN Dno == 5 THEN Salary + 2000
	WHEN Dno == 4 THEN Salary + 1500;
```

#### recursive query
如果沒有recursive query的話只能做到DDL

e.g.
```
WITH RECURSIVE SUP_EMP(SupSsn, EmpSsn) AS
SELECT SupervisorSsn, Ssn
FROM EMPLOYEE
	UNION
SELECT E.Ssn, S.SupSsn
FROM EMPLOYEE AS E, SUP_EMP AS S
WHERE E.SupervisorSsn == S.EmpSsn)
SELECT *
FROM SUP_EMP;
```

SUP_EMP是最重要的recursive的傳参值, 每一次執行SUP_EMP都會去遞迴上一層的結果
借此用有限的語句達成不限長度的操作可能

上司的上司跟上司都會被顯示在同一個table

直接在SQL中作recursive的案例比較少, 都常會引入其他語言來作協助


#### SQL structure
SELECT {attribute and function list }
FROM {table list}
> -- selectable --
WHERE {condition}
GROUP BY {grouping attribute(s)}
HAVING {group condition}
ORDER BY  {attribute list}

##### Virtual table(VIEW)
virtual table存在的時間筆tempuerey table還要久


使用CREATE VIEW後的table可以儲存起來, 提供後續其他的query使用
```
CREATE VIEW DEPT_INFO(Dept_name, No_of_emps, Total_sal)
AS
	SELECT Dname, COUNT(*), SUM(Salary)
	FROM DEPARTMENT, EMPLOYEE
	WHERE Dnumber == Dno
	GROUP BY Dname;
```

Virtual view會有 sync的必要, 太多virtual view可能會有潛在的系統負擔

常用的virtual 有甚麼方法 ： 
- Marco of CREAT VIEW -> 每次都要重新呼叫
- VIEW materialization -> 會有sync的問題

sync的時機 ： 
- immediate update -> 有值更新就更新所有view
- lazy update -> 等到被refer到後在update
- periodic update -> 設定時間定期update

update的問題 ： 當join後會有多個table對應到單個value, update時virtual不會知道現在要參考那一個(多對一), 此時會發生error(不允許發生)

因此建議CREATE VIEW 盡量減少ambigus的問題

##### Schema change statement

schema盡量不要動到, 應該在一開始就確定好, 但SQL也有提供熱修改的statement

通常是使用在增加新的schema, 更新或刪除都非常不建議