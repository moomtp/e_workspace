提供使用在botton up 的方式, 最好在上層的top-down結構設計完成後再從下面開始
##### Armstrong's inference rules:
- IR1. (Reflexive) If Y subset-of X, then X -> Y
- IR2. (Augmentation) If X -> Y, then XZ -> YZ
- IR3. (Transitive) If X -> Y and Y -> Z, then X -> Z

##### more inference rules:
- Decompotition : If X -> YZ, then X -> Y and X -> Z
- Union : If X -> Y, and X -> Z , then X -> YZ
- Psuedotransitibvity： If X -> Y and WY -> Z, then WX -> Z

#### Closure
- Closure of a set F of FDs is the set F+ of all FDs that can be inferred from F
- X+ can be calculated by repeatedly applying IR1, IR2, IR3 using the FDs in F

X : 是以attribute 的 closure
F : 是以FD為主的closure
+: 代表該closure滿足條件, 代表可以做BCNF

##### 計算closure algo.
```
X+ := X
repeat
	oldX+ := X+
	for each functional dependency Y -> Z in F do
		if Y is subset of X+, then X+ := X+ or Z;
	until(X+ = oldX+)
```


##### Algo. 用來測試lossless join property
```
Input: A universal relation R, a decomposition D = {R1, R2, ...} of R, and a set F of functional dependencies.
1. Create an initial matrix S with one row i for each relation Ri in D, and one column j for each attribute Aj in R.
2. Set S(i,j) = bij for all matrix entries. (* each bij is a distinct symbol associated with indices (i,j) *).
3. For each row i representing relation schema Ri
	   {for each column j representing attribute Aj
		   {if (relation Ri includes attribute Aj) then set S(i,j) = aj;};};
		(* each aj is a distinct symbil associated with index (j) *)
4. Repeat the following loop until a complete loop execution results in no changes to S
	   {for each functional dependency X -> Y in F
		   {for all rows in S which have the same symbols in the columns corresponding to attributes in X
			   {make the symbols in each column that correspond to an attribute in Y be the same in all these rows as follows:
				   If any of the rows has an "a" symbol for the column, set the other rows to that same "a" symbol in the column.
				   If no "a" symbol exists for the attriubte in any of the rows, choose one of the "b" symbols that appear ibn one of the rows for the attribute and set the other rows to that same "b" SYMBOL IN THE COLUMN;};
				};
			};
5. If a row is made up entirely of "a" symbols, then the decomposition has the lossless join property; otherwise it does not.
```

Problems with NULL values
- Dangaling null : 有可能會在join的時後發生問題, 如新進員工還沒有Dnum, 但用Dnum做join的時候會有問題, natural join會消失, left join才會保留, join後會把新的column都設成null
- 如果null value是發生在prime attribute那問題會更多(join不回來了)


##### out of realational database
> relational database絕對不是萬能的, 如在表述hierache結構等階層的架構時, 2維的relational database可能沒辦法完美解決
 e.g. data warehouse

-> Arithmetic functions想要試圖來解決, 但并不完備

Domain-key Normal Form (DKNF) ： 將每個attr根據不同domain來做切分, 但運算也極為龐大
-> 但也僅限在理論面, 比較少實用的場景











